% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reads_length_distribution.R
\name{reads_length_distribution}
\alias{reads_length_distribution}
\title{Generate the read length distribution of a fastq file}
\usage{
reads_length_distribution(
  fq.file,
  parallel.core = parallel::detectCores() - 1,
  with.future = FALSE
)
}
\arguments{
\item{fq.file}{(character, path). The path to the fastq file
(individal, lane or chip).
Default: \code{fq.file = "my-sample.fq.gz"}.}

\item{parallel.core}{(integer) Enable parallel execution with the number of threads.
Default: \code{parallel.core = parallel::detectCores() - 1}.}

\item{with.future}{(logical) When \code{TRUE} will use future package to run
the code in parallel. Set \code{parallel.core} to the number of physical, not
logical, cores. See example below.
Default: \code{with.future = FALSE}.}
}
\value{
The function returns a plot and a tibble with potential reads length
thresholds and associated number of reads.
}
\description{
This function reads the fastq file of an individual, lane or chip
and generate the read length distribution to help decide the threshold to cut the
reads to a specific length.
}
\details{
coming soon, just try it in the meantime...
}
\examples{
\dontrun{
require(ShortRead)
reads.length.info <- stackr::reads_length_distribution(
  fq.file = "my-sample.fq.gz")

 # with future package to get faster results:
 require(future)
 require(listenv)
 reads.length.info <- stackr::reads_length_distribution(
  fq.file = "my-sample.fq.gz",
  with.future = TRUE
  )
}
}
