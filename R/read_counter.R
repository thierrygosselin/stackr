#read_counter
#' @name read_counter
#' @title Counts the number of reads in samples
#' @description This function counts the number of reads in samples present
#' in the specified folder.
#' Useful if you don't have the info (e.g. generated by stacks process_radtags),
#' and you want to check the distribution in the number of reads between samples.

#' @param path.samples (character, path) Path of folder containing the
#' samples to count reads

#' @param strata (optional)
#' The strata file is a tab delimited file with 2 columns headers:
#' \code{INDIVIDUALS} and \code{STRATA}.
#' The \code{STRATA} column can be any hierarchical grouping.
#' To create a strata file see \code{\link[radiator]{individuals2strata}}.
#' If you have already run
#' \href{http://catchenlab.life.illinois.edu/stacks/}{stacks} on your data,
#' the strata file is similar to a stacks \emph{population map file}, make sure you
#' have the required column names (\code{INDIVIDUALS} and \code{STRATA}).
#' Note: Make sure that the fastq file names (without extension) match the INDIVIDUALS
#' column in the strata file. With default, figures are generated without strata
#' grouping.
#' Default: \code{strata = NULL}.

#' @param plot.reads With default \code{plot.reads = TRUE}, the distribution and
#' boxplot figures are generated and written in the directory.

#' @param write With default \code{write = TRUE}, the data frame with read counts
#' and figures are is written in the working directory.

#' @param parallel.core (optional) The number of core for parallel computing.
#' By default: \code{parallel.core = parallel::detectCores() - 1}.


#' @rdname read_counter
#' @export
#' @importFrom stringi stri_join stri_replace_all_fixed stri_sub stri_detect_fixed
#' @importFrom dplyr mutate filter distinct
#' @importFrom purrr keep walk pwalk pmap
#' @importFrom tibble data_frame

#' @return a list with a data frame with the sample id and the number of reads.
#' If option to generate figures was selected, the list also returns 2 figures
#' (see example below)

#' @examples
#' \dontrun{
#' library(stackr)
#' # To run this function, bioconductor \code{ShortRead} package is necessary:
#' source("http://bioconductor.org/biocLite.R")
#' biocLite("ShortRead")
#'
#' # Using OpenMP threads
#' nthreads <- .Call(ShortRead:::.set_omp_threads, 1L)
#' on.exit(.Call(ShortRead:::.set_omp_threads, nthreads))
#'
#' # with defaults
#' read.info <- stackr::read_counter(path.samples = "corals")
#'
#' # to extract info from the list
#' read.data = read.info$read.data
#' reads.distribution <- read.info$reads.distribution
#' reads.boxplot <- read.info$reads.boxplot
#'
#' # If the default figures saved were not good, save with new width and height
#' # the histogram
#' ggplot2::ggsave(
#' filename = "reads.distribution.pdf",
#' plot = reads.distribution,
#' width = 15, height = 15,
#' dpi = 600, units = "cm", useDingbats = FALSE, limitsize = FALSE)
#'
#' # the boxplot
#' ggplot2::ggsave(
#' filename = "reads.boxplot.pdf",
#' plot = reads.boxplot,
#' width = 15, height = 15,
#' dpi = 600, units = "cm", useDingbats = FALSE, limitsize = FALSE)
#' }


# @seealso
# \href{http://catchenlab.life.illinois.edu/stacks/comp/process_radtags.php}{process_radtags}.

# @references todo

read_counter <- function(
  path.samples,
  strata = NULL,
  plot.reads = TRUE,
  write = TRUE,
  parallel.core = parallel::detectCores() - 1
) {
  opt.change <- getOption("width")
  options(width = 70)
  cat("#######################################################################\n")
  cat("######################## stackr::read_counter #########################\n")
  cat("#######################################################################\n")
  timing <- proc.time()

  # Missing argument -----------------------------------------------------------
  # folder is given
  if (missing(path.samples)) stop("path.samples argument is required")

  # Check for required package -------------------------------------------------
  if (!requireNamespace("ShortRead", quietly = TRUE)) {
    stop("ShortRead needed for this function to work.
         Please follow the example for install instructions", call. = FALSE)
  }

  fastq.files <- list_sample_file(f = path.samples, full.path = TRUE)
  fastq.files.short <- list_sample_file(f = path.samples, full.path = FALSE)
  todo <- length(fastq.files)
  message("Number of samples to count: ", todo)

  message("\nCounting reads...")
  read.data <- .stackr_parallel(
    X = 1:todo,
    FUN = read_count_one,
    mc.cores = parallel.core,
    fastq.files, fastq.files.short) %>%
    dplyr::bind_rows(.) %>%
    dplyr::arrange(NUMBER_READS)

  message("\nTotal reads across samples= ", sum(read.data$NUMBER_READS))
  se <- round(sqrt(stats::var(read.data$NUMBER_READS)/length(read.data$NUMBER_READS)), 0)
  mean.reads <- round(mean(read.data$NUMBER_READS), 0)
  message("\nMean number of reads +/- SE [min - max] = ", mean.reads, " +/- ", se, " [", min(read.data$NUMBER_READS), " - ", max(read.data$NUMBER_READS), "]")

  if (plot.reads) {

    if (is.null(strata)) {
      read.data <- read.data %>% dplyr::mutate(STRATA = rep("overall", n()))
    }

    n.pop <- dplyr::n_distinct(read.data$STRATA)

    reads.distribution <- suppressMessages(ggplot2::ggplot(
      data = read.data, ggplot2::aes(x = NUMBER_READS)) +
        ggplot2::geom_histogram() +
        ggplot2::labs(x = "Number of reads") +
        ggplot2::labs(y = "Number of samples") +
        ggplot2::theme_bw() +
        ggplot2::theme(
          legend.position = "none",
          axis.title.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.text.x = ggplot2::element_text(size = 10, family = "Helvetica"),
          strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
        ))

    # the boxplot
    if (n.pop > 1) {
      width.plot <- n.pop * 10
    } else {
      width.plot <- 15
    }

    if (!is.null(strata)) {
      reads.distribution <- suppressMessages(
        reads.distribution +
          ggplot2::facet_grid(~STRATA, scales = "free", space = "free_x"))
    }

    suppressMessages(ggplot2::ggsave(
      filename = "reads.distribution.pdf",
      plot = reads.distribution,
      width = width.plot, height = 15,
      dpi = 600, units = "cm", useDingbats = FALSE, limitsize = FALSE))

    # boxplot
    reads.boxplot <- suppressMessages(
      ggplot2::ggplot(
        data = read.data,
        ggplot2::aes(x = STRATA, y = NUMBER_READS, colour = STRATA)) +
        ggplot2::geom_jitter(alpha = 0.5) +
        ggplot2::geom_violin(trim = TRUE, fill = NA) +
        ggplot2::geom_boxplot(width = 0.1, fill = NA, outlier.colour = NA, outlier.fill = NA) +
        ggplot2::labs(y = "Number of reads") +
        # ggplot2::labs(y = "Number of samples") +
        ggplot2::theme_bw() +
        ggplot2::theme(
          legend.position = "none",
          panel.grid.minor.x = ggplot2::element_blank(),
          panel.grid.major.y = ggplot2::element_blank(),
          axis.title.x = ggplot2::element_blank(),
          axis.title.y = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold"),
          axis.text.x = ggplot2::element_text(size = 10, family = "Helvetica"),
          strip.text.x = ggplot2::element_text(size = 10, family = "Helvetica", face = "bold")
        ))

    # the boxplot
    if (n.pop > 1) {
      width.plot <- n.pop * 10
    } else {
      width.plot <- 15
    }

    ggplot2::ggsave(
      filename = "reads.boxplot.pdf",
      plot = reads.boxplot,
      width = width.plot, height = 15,
      dpi = 600, units = "cm", useDingbats = FALSE, limitsize = FALSE)

  } else {
    reads.distribution <- "option not selected"
    reads.boxplot <- "option not selected"
  }

  if (write) {
    file.date <- format(Sys.time(), "%Y%m%d@%H%M")
    filename <- stringi::stri_join("stack_read_counts_", file.date, ".tsv")
    readr::write_tsv(x = read.data, path = filename)
    message("\nRead count file written: ", filename)
  }

  read.info <- list(read.data = read.data, reads.distribution = reads.distribution, reads.boxplot = reads.boxplot)


  timing <- proc.time() - timing
  message("\nComputation time: ", round(timing[[3]]), " sec")
  cat("############################## completed ##############################\n")
  options(width = opt.change)
  return(read.info)
}#read_counter


# Internal function ------------------------------------------------------------
#' @title read_count_one
#' @description count 1 fq file
#' @rdname read_count_one
#' @export
#' @keywords internal
read_count_one <- function(x, fastq.files, fastq.files.short) {
  # x <- 1
  fastq.files <- fastq.files[x]
  fastq.files.short <- fastq.files.short[x]

  sample.id <- stringi::stri_replace_all_fixed(
    str = fastq.files.short,
    pattern = unique(fq_file_type(fastq.files)),
    replacement = "", vectorize_all = FALSE)
  message("\nCounting the number of reads in sample: ", sample.id)

  n.reads <- length(ShortRead::readFastq(fastq.files))
  message("    Number of reads: ", n.reads)
  read.data <- tibble::as_tibble(list(INDIVIDUALS = sample.id, NUMBER_READS = n.reads))
  return(read.data)
}#End read_count_one
